let Observable,of,interval,from,fromEvent,fromEventPattern,range,throwError,concat,timer,iif,pipe,forkJoin,merge,race,map,reduce,filter,take,catchError,mergeMap,count,max,min,buffer,throttleTime,mapTo,delay,bufferCount,bufferTime,bufferToggle,bufferWhen,expand,groupBy,toArray,ajax,get,resolve,url,AnonymousSubject,callbackify;_363‍.w("rxjs",[["Observable",["Observable"],function(v){Observable=v}],["of",["of"],function(v){of=v}],["interval",["interval"],function(v){interval=v}],["from",["from"],function(v){from=v}],["fromEvent",["fromEvent"],function(v){fromEvent=v}],["fromEventPattern",["fromEventPattern"],function(v){fromEventPattern=v}],["range",["range"],function(v){range=v}],["throwError",["throwError"],function(v){throwError=v}],["concat",["concat"],function(v){concat=v}],["timer",["timer"],function(v){timer=v}],["iif",["iif"],function(v){iif=v}],["pipe",["pipe"],function(v){pipe=v}],["forkJoin",["forkJoin"],function(v){forkJoin=v}],["merge",["merge"],function(v){merge=v}],["race",["race"],function(v){race=v}]]);_363‍.w("rxjs/operators",[["map",["map"],function(v){map=v}],["reduce",["reduce"],function(v){reduce=v}],["filter",["filter"],function(v){filter=v}],["take",["take"],function(v){take=v}],["catchError",["catchError"],function(v){catchError=v}],["mergeMap",["mergeMap"],function(v){mergeMap=v}],["count",["count"],function(v){count=v}],["max",["max"],function(v){max=v}],["min",["min"],function(v){min=v}],["buffer",["buffer"],function(v){buffer=v}],["throttleTime",["throttleTime"],function(v){throttleTime=v}],["mapTo",["mapTo"],function(v){mapTo=v}],["delay",["delay"],function(v){delay=v}],["bufferCount",["bufferCount"],function(v){bufferCount=v}],["bufferTime",["bufferTime"],function(v){bufferTime=v}],["bufferToggle",["bufferToggle"],function(v){bufferToggle=v}],["bufferWhen",["bufferWhen"],function(v){bufferWhen=v}],["expand",["expand"],function(v){expand=v}],["groupBy",["groupBy"],function(v){groupBy=v}],["toArray",["toArray"],function(v){toArray=v}]]);_363‍.w("rxjs/ajax",[["ajax",["ajax"],function(v){ajax=v}]]);_363‍.w("http",[["get",["get"],function(v){get=v}]]);_363‍.w("path/posix",[["resolve",["resolve"],function(v){resolve=v}]]);_363‍.w("inspector",[["url",["url"],function(v){url=v}]]);_363‍.w("rxjs/internal/Subject",[["AnonymousSubject",["AnonymousSubject"],function(v){AnonymousSubject=v}]]);_363‍.w("util",[["callbackify",["callbackify"],function(v){callbackify=v}]]);







// var observable = Observable.create((observer: any) => {
//     observer.next('Hello World!');
//     observer.next('Welcome to JavaTpoint!');
//     observer.complete();
//     observer.next('Bye');
// })
// observable.subscribe(
//     (x: any) => logItem(x),
//     (error: any) => logItem('Error: ' + error),
//     () => logItem('This is the first Example')
// );
// function logItem(val: any) {
//     var node = document.createElement("li");
//     var textnode = document.createTextNode(val);
//     node.appendChild(textnode);
//     document.getElementById("list").appendChild(node);
// }


// var observer = new Observable(
//     function subscribe(subscriber) {
//         subscriber.next("My First Observable")
//     }
// );
// observer.subscribe(x => console.log(x));

// let test1 = of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
// let case1 = test1.pipe(
//     filter(x => x % 2 === 0),
//     reduce((acc, one) => acc + one, 0)
// )

// case1.subscribe(x => console.log(x))

// let test = interval(0.1);
// let case2 = test.pipe(take(5));

// case2.subscribe(x => console.log(x))
// const githubUsers = `https://api.github.com/users?per_page=5000`;
// const users = ajax.getJSON(githubUsers)
// const subscribe = users.subscribe(
//     res => console.log(res),
//     err => console.error(err)
// );


// let arr = from(test1)
// arr.subscribe(x => console.log(x))

// const promiseSou = from(new Promise(resolve => resolve("Hello javapoint")))

// const subscripbe = promiseSou.subscribe(val => console.log(val))

// function* gen(spped: any) {
//     let i = spped
//     while (true) {
//         yield i;
//         i = 2 * i;
//     }
// }

// const itre = gen(3);
// const result = from(itre).pipe(take(3))
// result.subscribe(val => console.log(val))

// const click = fromEvent(document, 'click')
// click.subscribe(x => console.log(x))

// const source = fromEvent(document, 'mouseover');
// const example = source.pipe(map(event => `Event Time: ${event.timeStamp}`))
// const sub = example.subscribe(val => console.log(val))


// function harsh(handl: any) {
//     document.addEventListener('click', handl)
// }

// function harsh2(handle: any) {
//     document.addEventListener('click', handle)

// }

// const clicks = fromEventPattern(
//     harsh,
//     harsh2
// )


// const nodeLikeRequest = (url: string, callback: (arg0: Date) => void) => {
//     setInterval(() => callback(new Date()), 1000)
// }

// const nodeLikeRequestAdaptor = (callback: any) => {
//     nodeLikeRequest('some url', callback)
// }

// fromEventPattern(
//     nodeLikeRequestAdaptor
// ).subscribe(console.log)


// const numbers = interval(1000)
// const getnum = numbers.pipe(take(8))

// getnum.subscribe(x => console.log(x))

// of([1, 2, 3, 4, 5, 6, 7, 8, 9])
//     .subscribe(
//         next => console.log('This is the next', next),
//         err => console.log("this is error", err),


//     )

// const source = of({ name: 'Alexa' }, function hello() {
//     return "Hello"
// })
// const sun = source.subscribe(val => console.log(val))


// const ran = range(1, 5)
// const ren = ran.subscribe(x => console.log(x))


// const errr = concat(of(1, 2, 3, 4, 5, 6, 7, 8, 9), throwError(new Error('Oops! Error is occurred')))
// errr.subscribe(x => console.log(x), e => console.log(e))

// interval(1000).pipe(
//     mergeMap(x => x === 56
//         ? throwError('This is an error message!')
//         : of('a', 'b', 'c')
//     ),
// ).subscribe(x => console.log(x), e => console.log(e))

// const time = timer(1);
// const subv = time.subscribe(val => console.log(val)
// )
// let junk = 0.3

// const source = timer(1000, junk)
// const syb = source.subscribe(x => console.log(x))


// const r$ = of("R")
// const x$ = of("X")
// interval(0.3)
//     .pipe(mergeMap(v => iif(() => v % 4 === 0, r$, x$)))

//     .subscribe(console.log);

// interval(100)
//     .pipe(mergeMap(v => iif(() => !!(v % 100), of(v), of(0))))
//     .subscribe(console.log);


// let nmu = of(1, 3, 5, 6, 12, 13, 24, 28)
// let val = nmu.pipe(count(a => a % 3 === 0))
// val.subscribe(x => console.log("This is your value " + x))

// const list1 = [11, 13, 26, 70, 58, 2, 40]
// const final = from(list1).pipe(min((a, b) => a + b));
// final.subscribe(x => console.log("The min value is " + x))
// let prodcuts: Array<any> = [
//     { id: 'A', price: 10000 },
//     { id: 'B', price: 7500 },
//     { id: 'C', price: 4500 },
//     { id: 'D', price: 5000 },
//     { id: 'E', price: 1000 },
// ]

// let total = from(prodcuts).pipe(reduce((acc, productsdet) => acc + productsdet.price, 0))
// total.subscribe(x => console.log("This is Your Total " + x))




// const clicks$ = fromEvent(document, "click")
// clicks$.pipe(buffer(clicks$.pipe(throttleTime(500))))
//     .subscribe(() => console.log("This is Your double click"))


// const my = interval(1000)
// const bufferva = fromEvent(document, "click")
// const bufferval = my.pipe(buffer(bufferva))
// const snf = bufferval.subscribe(val => console.log("This is your value ", val))

// const myInterval = interval(1000);
// //Create an observable that emits every time document is clicked
// const bufferBy = fromEvent(document, 'click');
// const myBufferedInterval = myInterval.pipe(buffer(bufferBy));
// const snj = myBufferedInterval.subscribe(val =>
//   console.log(' Buffered Values:', val)
// );  



// let list2 = of(1, 2, 3, 4, 5)
// let list3 = of(4, 5, 6, 7, 8, 9, 10, 11)
// let fin = race(list2, list3)

// fin.subscribe(x => console.log(x)
// )


// const f = interval(4000)
// const s = interval(3000)
// const t = interval(2000)
// const fa = interval(1000)

// const kl = merge(
//     f.pipe(mapTo("first")),
//     s.pipe(mapTo("second")),
//     t.pipe(mapTo("Third")),
//     fa.pipe(mapTo("fourth"))
// )

// kl.subscribe(x => console.log(x))

// const h = t.pipe()
// const y = h.subscribe(val => console.log(val))


// const example = race(
//     //emit every 1.5s  
//     interval(1500),
//     //emit every 1s  
//     interval(1000).pipe(mapTo('1s won!')),
//     //emit every 2s  
//     interval(2000),
//     //emit every 2.5s  
//     interval(2500)
// );
// const ag = example.subscribe(val => console.log(val));

// const first = of('first').pipe(
//     delay(100),
//     map(_ => {
//         throw 'warning';
//     })
// );
// const second = of('second').pipe(delay(200));
// const third = of('third').pipe(delay(300));
// race(first, second, third).subscribe(val => console.log(val));

// const sourc = interval(1000)
// const bufferThree = sourc.pipe(bufferCount(3, 1))
// const hju = bufferThree.subscribe(val => console.log(val))

// const click1 = interval(2000)
// const bufferd = click1.pipe(bufferTime(1000,1000))
// bufferd.subscribe(x => console.log(x))



// const sourceInterval = interval(1000);
// //start first buffer after 5s, and every 5s after  
// const startInterval = interval(1000);
// //emit value after 3s, closing corresponding buffer  
// const closingInterval = (val: any) => {
//     console.log(`Value ${val} emitted, starting buffer! Closing in 3s!`);
//     return interval(1000);
// };
// //every 5s a new buffer will start, collecting emitted values for 3s then emitting buffered values  
// const bufferToggleInterval = sourceInterval.pipe(
//     bufferToggle(startInterval, closingInterval)
// );
// const dd = bufferToggleInterval.subscribe(val =>
//     console.log('Emitted Buffer:', val)
// );


// console.clear();
// const getXYCoordinates = pipe(
//     map<[MouseEvent], {}>(e => e.map(v => ({ x: v.clientX, y: v.clientY }))),
//     map(e => JSON.stringify(e))
// )
// const ert = pipe(
//     bufferToggle(
//         fromEvent(document, 'mousedown'),
//         _ => fromEvent(document, 'mouseup')
//     )
// )
// fromEvent(document, 'mousemove')
//     .pipe(
//         ert,
//         getXYCoordinates
// const oneSecondInterval = interval(1000);
// //return an observable that emits value every 3 seconds  
// const threeSecondInterval = () => interval(2000);
// //every three seconds, emit buffered values  
// const bufferWhenExample = oneSecondInterval.pipe(
//     bufferWhen(threeSecondInterval)
// );
// const subscribe = bufferWhenExample.subscribe(val =>
//     console.log('Emitted Buffer values are: ', val)
// );  
//     ).subscribe(console.log);

// const powersOfTwo = of(1, 2, 3, 4, 5).pipe(
//     expand(x => of(x).pipe(delay(5000))),
//     take(10)
// );
// powersOfTwo.subscribe(x => console.log(x));  


const rtu = of(1);
const yt = rtu.pipe(
    expand(val => {
        console.log(`The Passed value is :${val}`)
        return of(1 + val)
    }),
    take(10)
)

const kju = yt.subscribe(x => _363‍.g.console.log(x))


const pepole = [
    { name: "harsh1", age: 18 },
    { name: "harsh2", age: 18 },
    { name: "harsh3", age: 18 },
    { name: "harsh4", age: 18 },
]

const cn = from(pepole)
const vh = cn.pipe(
    groupBy(person => person.age),
    mergeMap(group => group.pipe(toArray())),
)

const rt =vh.subscribe(x => _363‍.g.console.log(x))